"""
Plot results generated by "run_light_sheet_simulation.py"
                      and "run_light_sheet_acquisition.py"

Create a figure that compiles length and width calculations.

Also optionally can produce figures of the light sheets used in the analysis.

Note: Dictionary keys for reference are at the end of script.

2024/04/30 Steven Sheppard
"""
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import model_tools.raytrace as rt
from model_tools.analysis import plot_light_sheet
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt

# Plotting / debug flags
showfig = False
final_version = True
# Setup the saving / loading directories
savedir = rt.get_unique_dir("/mnt/tilingspim/extFOV_results",
                            "ls_model_results")

#-----------------------------------------------------------------------------#
# Load experimental and simualtion results
sim_dir = Path(
    "/mnt/server1/extFOV/light_sheet/simulations/20240717_152157_gaussian_light_sheet_model"
    )
acq_dir = Path(
    "/mnt/server1/extFOV/light_sheet/acquisitions/20240717_141851_ls_acq_results"
    )
# Compile result dictionaries
sim_fnames = [_fn for _fn in sim_dir.iterdir() if ".npy" in _fn.name]
acq_fnames = [_fn for _fn in acq_dir.iterdir() if ".npy" in _fn.name]
sim_results = [np.load(_fn, allow_pickle=True).item() for _fn in sim_fnames]
acq_results = [np.load(_fn, allow_pickle=True).item() for _fn in acq_fnames]

# Sort the results based on the value of the "etl_*" key
def sort_results_by_etl(results):
    return sorted(results,
                  key=lambda x: x[
                      "etl_amps" if "data" in x["label"] else "etl_dpt"
                      ]
                  )

r_sim_air = []
r_sim_wat = []
r_acq_air = []
r_acq_wat = []
for _r in sim_results:
    if "air" in _r["label"]:
        _r["results"] = sort_results_by_etl(_r["results"])
        r_sim_air.append(_r)
    elif "water" in _r["label"]:
        _r["results"] = sort_results_by_etl(_r["results"])
        r_sim_wat.append(_r)
for _r in acq_results:
    if "air" in _r["label"]:
        _r["results"] = sort_results_by_etl(_r["results"])
        r_acq_air.append(_r)
    elif "water" in _r["label"]:
        _r["results"] = sort_results_by_etl(_r["results"])
        r_acq_wat.append(_r)

# Sort based on aperture
r_sim_air = sorted(r_sim_air,
                   key=lambda x: x["results"][0]["aperture"])
r_sim_wat = sorted(r_sim_wat,
                   key=lambda x: x["results"][0]["aperture"])
r_acq_air = sorted(r_acq_air,
                   key=lambda x: x["results"][0]["aperture"])
r_acq_wat = sorted(r_acq_wat,
                   key=lambda x: x["results"][0]["aperture"])

result_dicts = r_sim_air + r_sim_wat + r_acq_air + r_acq_wat

#-----------------------------------------------------------------------------#
# Calculate remote focus distances with respect to the flat ETL.
for ii, result in enumerate(result_dicts):
    # Identify the native focal plane, ETL=0
    label = result["label"]
    etl_param_key = "etl_amps" if "data" in label else "etl_dpt"
    etl_params = np.array([_[etl_param_key] for _ in result["results"]])
    native_idx = np.where(etl_params==0)[0][0]
    native_fp = (result["results"][native_idx]["stage_positions"][0]
                 + result["results"][native_idx]["diffraction_focal_plane"])

    # Calculate the focal plane in stage units and dz from the native FP
    for _res in result["results"]:
        _res["focal_plane"] = (_res["stage_positions"][0]
                               + _res["diffraction_focal_plane"])
        _res["remote_focus_dz"] = _res["focal_plane"] - native_fp

    # Compile arrays of results
    rf_distances = np.array([_["remote_focus_dz"] for _ in result["results"]])
    # Compile length and widths to plot
    lengths = np.array([_["length"] for _ in result["results"]])
    widths = np.array([_["width"] for _ in result["results"]])

    # For comparison, only keep acquisitions/simulations over \pm 6mm
    to_keep = np.where(np.abs(rf_distances)<7500)[0]

    # Add compiled results to dict.
    result["remote_focus_dzs"] = rf_distances[to_keep]
    result["lengths"] = lengths[to_keep]
    result["widths"] = widths[to_keep]
    result["native_idx"] = native_idx
    result["to_keep"] = to_keep

#-----------------------------------------------------------------------------#
# Plot the length / width distributions for the data and simulation.
#-----------------------------------------------------------------------------#
# Define and create figure with grid
fig_shape=(6.5, 5.75)
axes_label_fontsize = 10
axes_legend_fontsize = 8
axes_tick_fontsize = 8
grid_width_ratio = [1, 0.05, 1, 0.05, 1, 0.1, 0.15]
grid_height_ratio = [1.5, 0.5, 1.0, 0.05, 1.0]

fig = plt.figure(figsize=fig_shape)
grid = fig.add_gridspec(nrows=len(grid_height_ratio),
                        ncols=len(grid_width_ratio),
                        width_ratios=grid_width_ratio,
                        height_ratios=grid_height_ratio,
                        wspace=0.01,
                        hspace=0.01
                        )

#-----------------------------------------------------------------------------#
# Create axes of the FWHM widths vs the lengths
ax = fig.add_subplot(grid[0,:])

# Plot experimental data w(L)
num_air = 0
num_wat = 0
num_acq_apts = len(acq_results)
for _r in acq_results:
    if "air" in _r["label"]:
        num_air +=1
    elif "water" in _r["label"]:
        num_wat += 1

# Map the different colors to the apterture
blues = plt.cm.Blues(np.linspace(0.3, 0.9, num_air))[::-1]
reds = plt.cm.Reds(np.linspace(0.3, 0.9, num_wat))[::-1]

def mkplot(ax, x, y, c, m, ms, ls, lb):
    ax.plot(x, y,
            color=c,
            marker=m,
            markersize=ms,
            linestyle=ls,
            label=lb
            )
    return None

air_cnt = 0
wat_cnt = 0
# Set marker for exp. results
m = '.'
ls='none'
for jj, _res in enumerate(r_acq_air+r_acq_wat):
    # assign color based on air/water
    if "air" in _res["label"]:
        color = blues[air_cnt]
        air_cnt +=1
        label="Exp. data in air"
    elif "water" in _res["label"]:
        color = reds[wat_cnt]
        wat_cnt += 1
        label="Exp. data in water"

    # Plot experimental results
    if wat_cnt==1 or air_cnt==1:
        # plot with legend on
        mkplot(ax, _res["lengths"], _res["widths"], color, m, 2, ls, None)
        mkplot(ax,
               _res["lengths"].mean(),
               _res["widths"].mean(),
               color, m, 15, ls, label
               )

    else:
        mkplot(ax, _res["lengths"], _res["widths"], color, m, 2, ls, None)
        mkplot(ax,
               _res["lengths"].mean(),
               _res["widths"].mean(),
               color, m, 15, ls, None
               )

# Plot the model results
air_mean = []
wat_mean = []
for _res in r_sim_air + r_sim_wat:
    if "air" in _res["label"]:
        air_mean.append([_res["lengths"].mean(), _res["widths"].mean()])
        label = "model in air"
        if len(air_mean)==len(r_sim_air):
            mkplot(ax,
                   np.array(air_mean)[:,0],
                   np.array(air_mean)[:,1],
                   "c", "x", 12, "--", label
                   )
    if "water" in _res["label"]:
        wat_mean.append([_res["lengths"].mean(), _res["widths"].mean()])
        label = "model in water"
        if len(wat_mean)==len(r_sim_wat):
            mkplot(ax,
                   np.array(wat_mean)[:,0],
                   np.array(wat_mean)[:,1],
                   "m", "x", 12, "--", label
                   )

# Change the axes properties
ax.set_ylabel("Width (um)", rotation=90, fontsize=axes_label_fontsize)
ax.set_xlabel("Length (um)", fontsize=axes_label_fontsize)
ax.grid()
ax.legend(fontsize=axes_legend_fontsize,
          loc="upper left",
          framealpha=1.0)

#-----------------------------------------------------------------------------#
# Plot heatmap light sheet results.
# Add plots of example light sheets.
# Start with two low NA examples
n_acq_air = len(r_acq_air)
n_sim_air = len(r_sim_air)
sim_etl = len(r_sim_air[n_sim_air-1]["results"])//2 -1
acq_etl = len(r_acq_air[n_acq_air-1]["results"])//2 -1
high_na_idx = [n_sim_air-1, n_acq_air-2]
low_na_idx = [3,2]
defocus_idx = [8,5]
high_na = [r_sim_air[high_na_idx[0]]["results"][sim_etl],
          r_acq_air[high_na_idx[1]]["results"][acq_etl]]
low_na = [r_sim_air[low_na_idx[0]]["results"][sim_etl],
          r_acq_air[low_na_idx[1]]["results"][15]]
defocused = [r_sim_wat[defocus_idx[0]]["results"][0],
             r_acq_wat[defocus_idx[1]]["results"][-2]]

# plot args
x_range = 50

# Plot high NA examples
sim_ax_h = fig.add_subplot(grid[2,0])
acq_ax_h = fig.add_subplot(grid[4,0])
z_range = 90
plot_light_sheet(high_na[0],
                 show_edges = True,
                 show_legend=False,
                 ax = sim_ax_h,
                 z_range=z_range,
                 x_range=x_range)
im = plot_light_sheet(high_na[1],
                      show_edges = True,
                      show_legend=False,
                      ax = acq_ax_h,
                      z_range=z_range,
                      x_range=x_range,
                      return_im=True)
sim_ax_h.tick_params(axis="x",
                    which="both",
                    labelbottom=False,
                    labelleft=True,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=True,
                    right=False
                    )
acq_ax_h.tick_params(axis="x",
                    which="both",
                    labelbottom=False,
                    labelleft=True,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=True,
                    right=False
                    )
# Plot low NA examples
sim_ax_L = fig.add_subplot(grid[2,2])
acq_ax_L = fig.add_subplot(grid[4,2])
z_range = 200
plot_light_sheet(low_na[0],
                 show_edges = True,
                 show_legend=False,
                 ax = sim_ax_L,
                 z_range=z_range,
                 x_range=x_range)
im = plot_light_sheet(low_na[1],
                      show_edges = True,
                      show_legend=False,
                      ax = acq_ax_L,
                      z_range=z_range,
                      x_range=x_range,
                      return_im=True)
sim_ax_L.tick_params(axis="both",
                    which="both",
                    labelbottom=False,
                    labelleft=False,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=False,
                    right=False
                    )
acq_ax_L.tick_params(axis="both",
                    which="both",
                    labelbottom=False,
                    labelleft=False,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=False,
                    right=False
                    )

# Plot defocused example
sim_ax_d = fig.add_subplot(grid[2,4])
acq_ax_d = fig.add_subplot(grid[4,4])
z_range = 109
im = plot_light_sheet(defocused[0],
                 show_edges = True,
                 show_legend=False,
                 ax = sim_ax_d,
                 z_range=z_range,
                 x_range=x_range,
                 return_im=True)
im = plot_light_sheet(defocused[1],
                      show_edges = True,
                      show_legend=False,
                      ax = acq_ax_d,
                      z_range=z_range,
                      x_range=x_range,
                      return_im=True)
sim_ax_d.tick_params(axis="both",
                    which="both",
                    labelbottom=False,
                    labelleft=False,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=False,
                    right=False
                    )

acq_ax_d.tick_params(axis="both",
                    which="both",
                    labelbottom=False,
                    labelleft=False,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=False,
                    right=False
                    )

show_edges = True,
cbax = fig.add_subplot(grid[2:,-1])
cbar = plt.colorbar(im, cax=cbax)
cbar.set_ticks([0.0, 0.2, 0.4, 0.6, 0.8, 1.0])

# Save figure
fig.savefig(savedir / Path("lengths_vs_widths.pdf"))
