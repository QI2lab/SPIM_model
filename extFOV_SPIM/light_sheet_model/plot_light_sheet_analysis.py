"""
Plot results generated by "run_light_sheet_simulation.py"
                      and "run_light_sheet_acquisition.py"

Create a figure that compiles length and width calculations.

Also optionally can produce figures of the light sheets used in the analysis.

Note: Dictionary keys for reference are at the end of script.

2024/04/30 Steven Sheppard
"""

import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import model_tools.raytrace as rt
import model_tools.propagation as pt
from matplotlib_scalebar.scalebar import ScaleBar

# from model_tools.analysis import plot_light_sheet

# imports
from pathlib import Path
import numpy as np

import matplotlib.pyplot as plt


# Plotting / debug flags
showfig = False
final_version = True
# Setup the saving / loading directories
savedir = rt.get_unique_dir("/mnt/server1/extFOV/light_sheet/analysis_results",
                            "lightsheet_comparison_150100")

#-----------------------------------------------------------------------------#
# Load experimental and simualtion results
#-----------------------------------------------------------------------------#
sim_dir = Path(
    "/mnt/server1/extFOV/light_sheet/simulations/20240715_120957_150100_60_gaussian"
    )
acq_dir = Path(
    "/mnt/server1/extFOV/light_sheet/acquisitions/to_plot_results"
    )
# Compile result dictionaries
sim_fnames = [_fn for _fn in sim_dir.iterdir() if ".npy" in _fn.name]
acq_fnames = [_fn for _fn in acq_dir.iterdir() if ".npy" in _fn.name]
sim_results = [np.load(_fn, allow_pickle=True).item() for _fn in sim_fnames]
acq_results = [np.load(_fn, allow_pickle=True).item() for _fn in acq_fnames]

# Sort the results based on the value of the "etl_*" key
def sort_results_by_etl(results):
    return sorted(results,
                  key=lambda x: x[
                      "etl_amps" if "data" in x["label"] else "etl_dpt"
                      ]
                  )

r_sim_air = []
r_sim_wat = []
r_acq_air = []
r_acq_wat = []
for _r in sim_results:
    if "air" in _r["label"]:
        _r["results"] = sort_results_by_etl(_r["results"])
        r_sim_air.append(_r)
    elif "water" in _r["label"]:
        _r["results"] = sort_results_by_etl(_r["results"])
        r_sim_wat.append(_r)
for _r in acq_results:
    if "air" in _r["label"]:
        _r["results"] = sort_results_by_etl(_r["results"])
        r_acq_air.append(_r)
    elif "water" in _r["label"]:
        _r["results"] = sort_results_by_etl(_r["results"])
        r_acq_wat.append(_r)

# Sort based on aperture
r_sim_air = sorted(r_sim_air,
                   key=lambda x: x["results"][0]["aperture"])
r_sim_wat = sorted(r_sim_wat,
                   key=lambda x: x["results"][0]["aperture"])
r_acq_air = sorted(r_acq_air,
                   key=lambda x: x["results"][0]["aperture"])
r_acq_wat = sorted(r_acq_wat,
                   key=lambda x: x["results"][0]["aperture"])

result_dicts = r_sim_air + r_sim_wat + r_acq_air + r_acq_wat

#-----------------------------------------------------------------------------#
# Calculate remote focus distances with respect to the flat ETL.
# Create figure showing the dz vs damp and dz vs dpt
#-----------------------------------------------------------------------------#
fig_etl, axs = plt.subplots(1,2,figsize=(8,4))
fig_etl.suptitle("ETL analysis, color -> aperture")

# modify amp plot
ax = axs[0]
ax.set_title("Optotune Amps")
ax.set_ylabel("amp")
ax.set_xlabel("dz")
# modify dpt plot
ax = axs[1]
ax.set_title("Model ETL dpt")
ax.set_ylabel("dpt")
ax.set_xlabel("dz")
cmaps = plt.cm.get_cmap('hsv', len(result_dicts))

# Calculate RF dz and plot results
for ii, result in enumerate(result_dicts):
    label = result["label"]

    # Identify the native focal plane, ETL=0
    etl_param_key = "etl_amps" if "data" in label else "etl_dpt"
    etl_params = np.array([_[etl_param_key] for _ in result["results"]])
    native_idx = np.where(etl_params==0)[0][0]
    native_fp = (result["results"][native_idx]["stage_positions"][0]
                 + result["results"][native_idx]["diffraction_focal_plane"])

    # Calculate the focal plane in stage units and dz from the native FP
    for _res in result["results"]:
        _res["focal_plane"] = (_res["stage_positions"][0]
                               + _res["diffraction_focal_plane"])
        _res["remote_focus_dz"] = _res["focal_plane"] - native_fp

    # Compile arrays of results
    rf_distances = np.array([_["remote_focus_dz"] for _ in result["results"]])

    # Compile length and widths to plot
    lengths = np.array([_["length"] for _ in result["results"]])
    widths = np.array([_["width"] for _ in result["results"]])

    # For comparison, only keep acquisitions/simulations over \pm 6mm
    to_keep = np.where(np.abs(rf_distances)<7500)[0]

    # Add compiled results to dict.
    result["remote_focus_dzs"] = rf_distances[to_keep]
    result["lengths"] = lengths[to_keep]
    result["widths"] = widths[to_keep]
    result["native_idx"] = native_idx
    result["to_keep"] = to_keep

    # Add the results to the remote focus distance plot
    ax_index = 0 if "data" in label else 1
    ax = axs[ax_index]
    ax.plot(rf_distances,
            etl_params,
            color=cmaps(ii),
            marker='.',
            linestyle='--')

# save figure
fig_etl.savefig(savedir / Path("etl_param_vs_dz.png"), dpi=300)

#-----------------------------------------------------------------------------#
# Plot the length / width distributions for the data and simulation.
#-----------------------------------------------------------------------------#
# Define and create figure with grid
fig_shape=(6.5, 5.75)
axes_label_fontsize = 10
axes_legend_fontsize = 8
axes_tick_fontsize = 8
grid_width_ratio = [1, 0.05, 1, 0.05, 1, 0.1, 0.15]
grid_height_ratio = [1.5, 0.5, 1.0, 0.05, 1.0]

fig = plt.figure(figsize=fig_shape)
grid = fig.add_gridspec(nrows=len(grid_height_ratio),
                        ncols=len(grid_width_ratio),
                        width_ratios=grid_width_ratio,
                        height_ratios=grid_height_ratio,
                        wspace=0.01,
                        hspace=0.01
                        )

#-----------------------------------------------------------------------------#
# Create axes of the FWHM widths vs the lengths
ax = fig.add_subplot(grid[0,:])

# Plot experimental data w(L)
num_air = 0
num_wat = 0
num_acq_apts = len(acq_results)
for _r in acq_results:
    if "air" in _r["label"]:
        num_air +=1
    elif "water" in _r["label"]:
        num_wat += 1

# Map the different colors to the apterture
blues = plt.cm.Blues(np.linspace(0.3, 0.9, num_air))[::-1]
reds = plt.cm.Reds(np.linspace(0.3, 0.9, num_wat))[::-1]

def mkplot(ax, x, y, c, m, ms, ls, lb):
    ax.plot(x, y,
            color=c,
            marker=m,
            markersize=ms,
            linestyle=ls,
            label=lb
            )
    return None

air_cnt = 0
wat_cnt = 0
# Set marker for exp. results
m = '.'
ls='none'
for jj, _res in enumerate(r_acq_air+r_acq_wat):
    # assign color based on air/water
    if "air" in _res["label"]:
        color = blues[air_cnt]
        air_cnt +=1
        label="Exp. data in air"
    elif "water" in _res["label"]:
        color = reds[wat_cnt]
        wat_cnt += 1
        label="Exp. data in water"

    # Plot experimental results
    if wat_cnt==1 or air_cnt==1:
        # plot with legend on
        mkplot(ax, _res["lengths"], _res["widths"], color, m, 2, ls, None)
        mkplot(ax,
               _res["lengths"].mean(),
               _res["widths"].mean(),
               color, m, 15, ls, label
               )

    else:
        mkplot(ax, _res["lengths"], _res["widths"], color, m, 2, ls, None)
        mkplot(ax,
               _res["lengths"].mean(),
               _res["widths"].mean(),
               color, m, 15, ls, None
               )

# Plot the model results
air_mean = []
wat_mean = []
for _res in r_sim_air + r_sim_wat:
    if "air" in _res["label"]:
        air_mean.append([_res["lengths"].mean(), _res["widths"].mean()])
        label = "model in air"
        if len(air_mean)==len(r_sim_air):
            mkplot(ax,
                   np.array(air_mean)[:,0],
                   np.array(air_mean)[:,1],
                   "c", "x", 12, "--", label
                   )
    if "water" in _res["label"]:
        wat_mean.append([_res["lengths"].mean(), _res["widths"].mean()])
        label = "model in water"
        if len(wat_mean)==len(r_sim_wat):
            mkplot(ax,
                   np.array(wat_mean)[:,0],
                   np.array(wat_mean)[:,1],
                   "m", "x", 12, "--", label
                   )

# Change the axes properties
ax.set_ylabel("Width (um)", rotation=90, fontsize=axes_label_fontsize)
ax.set_xlabel("Length (um)", fontsize=axes_label_fontsize)
ax.grid()
ax.legend(fontsize=axes_legend_fontsize,
          loc="upper left",
          framealpha=1.0)

#-----------------------------------------------------------------------------#
# Plot heatmap light sheet results.

def plot_light_sheet(results,
                     show_focal_planes = False,
                     show_edges = False,
                     show_legend=False,
                     ax = None,
                     ax_title = None,
                     show_cbar = False,
                     show_scale = False,
                     scale_length = 50,
                     z_range=50,
                     x_range=25,
                     return_im=False):
    ls_slice = results["light_sheet_slice"]
    dx = results["dx"]
    dz = results["dz"]
    fp = np.argmin(np.abs(results["stage_positions"]
                           - results["diffraction_focal_plane"])
                   )
    if z_range or x_range:
        # Crop light sheet array down before plotting
        n_z = ls_slice.shape[0]
        n_xy = ls_slice.shape[1]

        if z_range and x_range:
            z_trim = int((z_range/dz)/2)
            x_trim = int((x_range/dx)/2)
            ls_slice = ls_slice[fp-z_trim:fp+z_trim,
                                n_xy//2-x_trim:n_xy//2+x_trim
                                ]

        elif z_range and x_range is None:
            z_trim = int((z_range/dz)/2)
            ls_slice = ls_slice[fp-z_trim:fp+z_trim,
                                :]
        elif x_range and z_range is None:
            x_trim = int((x_range/dx)/2)
            ls_slice = ls_slice[:,
                                n_xy//2-x_trim:n_xy//2+x_trim
                                ]
    else:
        fp = np.argmin(np.abs(results["stage_positions"]
                              - results["diffraction_focal_plane"]))

    n_zx, n_xy, = ls_slice.shape
    # Enforce odd numbers
    if n_xy%2 == 0:
        n_xy += 1
    if n_zx%2 == 0:
        n_zx += 1
    grid_params = pt.field_grid(num_xy=n_xy,
                                num_zx=n_zx,
                                dx=dx,
                                dz=dz,
                                return_field=False
                                )
    try:
        z_start = results["stage_positions"][fp-n_zx//2]
        grid_params[-1][0] += 0
        grid_params[-1][1] += results["stage_positions"][fp+n_zx//2] - z_start
    except:
        zmax = max([len(results["stage_positions"]) - fp, fp])
        z_start = results["stage_positions"][fp-zmax//2]
        grid_params[-1][0] += 0
        grid_params[-1][1] += results["stage_positions"][fp+zmax//2] - z_start
        print(f"z_range is too large, zmax={zmax}")


    if ax is None:
        fig, ax = plt.subplots(1,1, figsize=(7,3))
        ax.set(ylabel="r ($\me m$)", xlabel="z (\mu m$")
        show_cbar=True

    if ax_title is not None:
        ax.set_title(ax_title)

    im = ax.imshow(np.rot90(ls_slice/ls_slice.max(),1),
                    cmap='hot',
                    extent=grid_params[-1],
                    aspect='auto',
                    origin='lower',
                    interpolation=None,
                    vmin=0, vmax=1
                    )
    # add results to top corner of plot
    ax.text(0.05, 0.95,
            f"L: {results['length']:.0f}$\mu m$\nW: {results['width']:.1f}$\mu m$",
            color="white",
            fontsize=9,
            ha="left", va="top",
            transform=ax.transAxes)

    if show_edges:
        ax.axvline(x=results["diffraction_focal_plane"] - z_start,
                    label="focal plane",
                    linestyle="-",
                    color="white"
                    )
        try:
            ax.axvline(x=results["left_edge"] - z_start,
                        label="edge",
                        linestyle="--",
                        color="white"
                        )
            ax.axvline(x=results["right_edge"] - z_start,
                        linestyle="--",
                        color="white"
                        )
        except:
            pass
    if show_focal_planes:
        ax.axvline(x=results["midpoint_focal_plane"] - z_start,
                    label="mipoint",
                    linestyle="--",
                    color="g"
                    )
        ax.axvline(x=results["paraxial_focal_plane"] - z_start,
                    label="paraxial",
                    linestyle="--",
                    color="limegreen"
                    )
        ax.axvline(x=results["marginal_focal_plane"] - z_start,
                    label="marginal",
                    linestyle="--",
                    color="red"
                    )
    if show_legend:
        ax.legend(fontsize=7,
                  framealpha=0.1,
                  labelcolor="white"
                  )
    if show_scale is True:
        scalebar = ScaleBar(dx=1,
                            units="um",
                            location='lower right',
                            fixed_value=scale_length,
                            fixed_units="um",
                            dimension="si-length",
                            color='white',
                            frameon=False,
                            box_alpha=0.2
                            )
        ax.add_artist(scalebar)

        # # manually draw scalebar
        # q = scale_length / (n_zx * dz)
        # print(q)
        # ax.axhline(y=0,
        #            xmin=grid_params[-1][0],
        #            xmax=grid_params[-1][0]+ scale_length,
        #            color="white", ls="-", lw=1)

    if show_cbar:
        plt.colorbar(im)
    if return_im:
        return im
    else:
        return None

# Add plots of example light sheets.
# Start with two low NA examples
n_acq_air = len(r_acq_air)
n_sim_air = len(r_sim_air)
sim_etl = len(r_sim_air[n_sim_air-1]["results"])//2 -1
acq_etl = len(r_acq_air[n_acq_air-1]["results"])//2 -1
high_na_idx = [n_sim_air-1, n_acq_air-2]
low_na_idx = [2,2]
defocus_idx = [5,5]
high_na = [r_sim_air[high_na_idx[0]]["results"][sim_etl],
          r_acq_air[high_na_idx[1]]["results"][acq_etl]]
low_na = [r_sim_air[low_na_idx[0]]["results"][sim_etl],
          r_acq_air[low_na_idx[1]]["results"][acq_etl]]
defocused = [r_sim_wat[defocus_idx[0]]["results"][1],
             r_acq_wat[defocus_idx[1]]["results"][-2]]

# plot args
show_scale = False
x_range = 50

# Plot high NA examples
sim_ax_h = fig.add_subplot(grid[2,0])
acq_ax_h = fig.add_subplot(grid[4,0])
z_range = 90
plot_light_sheet(high_na[0],
                 show_edges = True,
                 show_legend=False,
                 ax = sim_ax_h,
                 show_scale=show_scale,
                 scale_length=25,
                 z_range=z_range,
                 x_range=x_range)
im = plot_light_sheet(high_na[1],
                      show_edges = True,
                      show_legend=False,
                      ax = acq_ax_h,
                      show_scale=show_scale,
                      scale_length=25,
                      z_range=z_range,
                      x_range=x_range,
                      return_im=True)
sim_ax_h.tick_params(axis="x",
                    which="both",
                    labelbottom=False,
                    labelleft=True,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=True,
                    right=False
                    )
acq_ax_h.tick_params(axis="x",
                    which="both",
                    labelbottom=False,
                    labelleft=True,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=True,
                    right=False
                    )
# Plot low NA examples
sim_ax_L = fig.add_subplot(grid[2,2])
acq_ax_L = fig.add_subplot(grid[4,2])
z_range = 180
plot_light_sheet(low_na[0],
                 show_edges = True,
                 show_legend=False,
                 ax = sim_ax_L,
                 show_scale=show_scale,
                 scale_length=100,
                 z_range=z_range,
                 x_range=x_range)
im = plot_light_sheet(low_na[1],
                      show_edges = True,
                      show_legend=False,
                      ax = acq_ax_L,
                      show_scale=show_scale,
                      scale_length=100,
                      z_range=z_range,
                      x_range=x_range,
                      return_im=True)
sim_ax_L.tick_params(axis="both",
                    which="both",
                    labelbottom=False,
                    labelleft=False,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=False,
                    right=False
                    )

acq_ax_L.tick_params(axis="both",
                    which="both",
                    labelbottom=False,
                    labelleft=False,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=False,
                    right=False
                    )

# Plot defocused example
sim_ax_d = fig.add_subplot(grid[2,4])
acq_ax_d = fig.add_subplot(grid[4,4])
z_range = 120
im = plot_light_sheet(defocused[0],
                 show_edges = True,
                 show_legend=False,
                 ax = sim_ax_d,
                 show_scale=show_scale,
                 scale_length=50,
                 z_range=z_range,
                 x_range=x_range,
                 return_im=True)
im = plot_light_sheet(defocused[1],
                      show_edges = True,
                      show_legend=False,
                      ax = acq_ax_d,
                      show_scale=show_scale,
                      scale_length=50,
                      z_range=z_range,
                      x_range=x_range,
                      return_im=True)
sim_ax_d.tick_params(axis="both",
                    which="both",
                    labelbottom=False,
                    labelleft=False,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=False,
                    right=False
                    )

acq_ax_d.tick_params(axis="both",
                    which="both",
                    labelbottom=False,
                    labelleft=False,
                    labelright=False,
                    labeltop=False,
                    bottom=False,
                    top=False,
                    left=False,
                    right=False
                    )

show_edges = True,
cbax = fig.add_subplot(grid[2:,-1])
cbar = plt.colorbar(im, cax=cbax)
cbar.set_ticks([0.0, 0.2, 0.4, 0.6, 0.8, 1.0])
if final_version:
    fig.savefig(savedir / Path("lengths_vs_widths.svg"))
else:
    fig.savefig(savedir / Path("lengths_vs_widths.png"))


#-----------------------------------------------------------------------------#
# plot the defocus results
#-----------------------------------------------------------------------------#
grid_height_ratio = [1,0.2,1]
grid_width_ratio = [1,0.2,1]
fig_shape = (8,8)
fig = plt.figure(figsize=fig_shape)
grid = fig.add_gridspec(nrows=len(grid_height_ratio),
                        ncols=len(grid_width_ratio),
                        width_ratios=grid_width_ratio,
                        height_ratios=grid_height_ratio,
                        wspace=0.1,
                        hspace=0.1
                        )

ax = fig.add_subplot(grid[0,0])
ax.set_title("In air results")
ax.set_xlabel("remote focus dz $(\mu m)$")
ax.set_ylabel("$\omega_0$")

# plot the focal params as function of remote focus distance
for _res in r_acq_air:
    ax.plot(_res["remote_focus_dzs"], _res["widths"], "--")

ax = fig.add_subplot(grid[0,2], sharey=ax, sharex=ax)
ax.set_title("In air results")
ax.set_xlabel("remote focus dz $(\mu m)$")

for _res in r_acq_wat:
    ax.plot(_res["remote_focus_dzs"], _res["widths"], "--")

# plot the model
ax = fig.add_subplot(grid[2,0], sharex=ax)
ax.set_title("In air results")
ax.set_xlabel("remote focus dz $(\mu m)$")
ax.set_ylabel("$\omega_0$")

for _res in r_sim_air:
    ax.plot(_res["remote_focus_dzs"], _res["widths"], "--")

ax = fig.add_subplot(grid[2,2], sharey=ax, sharex=ax)
ax.set_title("In air results")
ax.set_xlabel("remote focus dz $(\mu m)$")

for _res in r_sim_wat:
    ax.plot(_res["remote_focus_dzs"], _res["widths"], "--")