'''
Test PSF simulation.

Iterate through NAs and compare to airy disk distribution at the focus.

06/09/2023
Steven Sheppard
'''
from pathlib import Path
import matplotlib.pyplot as plt
import numpy as np

import model_tools.propagation as pt
import model_tools.analytic_forms as af
import model_tools.analysis as an
import model_tools.raytrace as rt

'''
Generate a perfect electric field, independent of raytracing and propagate. It should yeild the perfect results.
'''

showfig = True
show_initial_phase_comparison = False
verify_energy_conservation = True
# Unit conversion, um -> mm: * , mm -> um: /
mm = 1e-3

root_dir = Path('/home/steven/Documents/qi2lab/github/raytracing_sjs/data')
savedir = rt.get_unique_dir(root_dir, Path('test_psf'))

show_napari=True

#------------------------------------------------------------------------------#
# Setup for propagation
wl = 0.561 * mm
ko = 2 * np.pi / wl
initial_propagation_diameter = 500 * mm
propagation_length = 100 * mm
dx = wl / 2
dz = wl * 4
n_xy = int(initial_propagation_diameter // dx)
n_zx = int(propagation_length // dz)

# Check if n_grid is odd
if n_xy%2 == 0:
    n_xy += 1
if n_zx%2 == 0:
    n_zx += 1

#------------------------------------------------------------------------------#
na=0.14
f = 40

# generate rays
rays = rt.create_rays(type='flat_top',
                      source='infinity',
                      n_rays=1e6,
                      diameter=f * na *2.0)

# Create objective
obj = rt.Perfect_lens(z1=f, f=f, na=na, ri_in=1.0, ri_out=1.0)

# ray trace objective
rays = obj.raytrace(rays)

# find the focal plane
focal_plane = rt.ray_focal_plane(rays=rays, ri=1.0, method='paraxial')

# Prepare electric field grid
grid, grid_params = pt.field_grid(num_xy=n_xy, num_zx=n_zx, dx=dx, dz=dz)
x, radius_xy, extent_xy, z, extent_zx = grid_params

# offset z to the focal plane
z_real = z + focal_plane

# ray trace to propagation plane
rays_to_field_z = rt.rays_to_field_plane(rays=rays,
                                         x_max=x.max(),
                                         padding=0.050)

# The propagate() takes the distance from initial field to the field plane
z_prop = z_real - rays_to_field_z

# how far is the initial field from the focus?
initial_field_distance_to_focus = focal_plane - rays_to_field_z

# ray trace to the rays -> field plane
rays = rt.intersect_plane(rays, rays_to_field_z, ri_in=1.0, refract=False)

rt.plot_rays(rays=rt.intersect_optical_axis(rays, ri=1.0),
             n_rays_to_plot=1001,
             optical_train = [obj],
             planes_of_interest={'rays to field':rays_to_field_z,
                                 'paraxial fp':focal_plane},
             save_path=None,
             showfig=False,
             figsize=(15,8))

# generate an electric field that has a uniform amplitude in x and y
#   and has the phase map generated by a perfect defocus
raytrace_field_amp = rt.rays_to_field(mask_radius=radius_xy,
                                     rays=rays,
                                     ko=ko,
                                     amp_binning=n_xy//5,
                                     amp_type='power',
                                     results='amplitude',
                                     plot_field=False,
                                     showfig=False)

# Calculate the phase on a 2d grid
analytic_opl = af.defocused_opl(radius_xy,
                                dz=-initial_field_distance_to_focus,
                                ri=1.0)

analytic_field_phase = ko * (analytic_opl - analytic_opl.min())

# Create a set of fake rays that have this OPL
analytic_phase_rays = np.zeros((1, n_xy, 4))
analytic_phase_rays[-1, :, 0] = x
analytic_phase_rays[-1, :, 1] = None
analytic_phase_rays[-1, :, 2] = rays_to_field_z
analytic_phase_rays[-1, :, 3] = analytic_opl[n_xy//2, :]

# grab the phase mask generated by rays_to_field
simulation_phase = rt.rays_to_field(mask_radius=radius_xy,
                                    rays=rays,
                                    ko=ko,
                                    amp_binning=n_xy//5,
                                    results='phase',
                                    phase_type='opld',
                                    plot_field=False,
                                    showfig=False)

if show_initial_phase_comparison:
    # Plot comparison
    fix, ax = plt.subplots(1,1)
    ax.set_ylabel('Path length')
    ax.set_xlabel('radius (mm)')
    ax.set_title('Path length comparison')

    # ax.plot(x, analytic_phase_rays[-1, :, 3] - analytic_phase_rays[-1, :, 3].min(), 'bx', label='analytic')
    ax.plot(x, analytic_field_phase[n_xy//2,:]/ko, 'bx', label='analytic')
    ax.plot(x, -simulation_phase[n_xy//2,:]/ko, 'r.', label='sim')

    ax.legend()
    plt.show()


# generate an electric field using the ray trace amplitude distribution and analytic phase
initial_field_analytic_phase = raytrace_field_amp * np.exp(-1j * analytic_field_phase)

# generate simulation electric field using ray trace result to electric field
initial_field_simulation = rt.rays_to_field(mask_radius=radius_xy,
                                            rays=rays,
                                            ko=ko,
                                            amp_binning=n_xy//5,
                                            amp_type='power',
                                            phase_type='opld',
                                            results='field',
                                            power=0.01,
                                            plot_field=False,
                                            showfig=True)


# Propagate the initial fields to get a 3d distribution about the focus
field_simulation = pt.get_3d_field(initial_field_simulation,
                                   z=z_real - rays_to_field_z,
                                   wl=wl,
                                   dx=dx,
                                   ri=1.0,
                                   DEBUG=False,
                                   save_path=None,
                                   showfig=False)


if verify_energy_conservation:
    # Calculate the power contained in the initial field
    initial_power = pt.calc_field_power(initial_field_simulation, dx=dx)

    # Calculate the total power at each z plane
    field_simulation_power = np.array([pt.calc_field_power(field, dx=dx) for field in field_simulation])

    # Plot the energy conservation
    fig, ax=plt.subplots(1,1, figsize=(8,10))
    fig.suptitle('Test energy conservation')
    ax.set_title(f"initial field power:{initial_power:.0e}")
    ax.plot(z, field_simulation_power, 'r.', label='integrated power')
    ax.axhline(y=initial_power, label='initial field power')
    ax.set_xlabel("z (um)")
    ax.set_ylabel("Power")
    ax.legend()

pt.plot_field(fields=[initial_field_analytic_phase, initial_field_simulation],
              field_labels=['analytic phase', 'rays to field'],
              grid_params=[grid_params, grid_params],
              fig_title='Initial field comparison',
              gamma_scale=1.0,
              save_path=None,
              showfig=True)

best_waist = af.gauss_waist(wl=wl, ri=1.0, na=obj.na)
best_length = 2 * af.gauss_rayleigh(wl=wl, na=obj.na)

results = {"light_sheet_slice":np.abs(field_simulation[:, n_xy//2,:])**2,
           "stage_positions":np.linspace(0,1,100000),
           "dx":dx*1e3,
           "dz":dz*1e3}
ls_analysis = an.light_sheet_analysis(results=results,
                                      width_scale=0.5,
                                      w_window=1,
                                      i_window=1,
                                      w_filter=[0,100],
                                      plot_acq_results=True,
                                      showfig=True)